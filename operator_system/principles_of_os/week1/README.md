# 第一讲   
## 操作系统做了什么       
```    
#include <stdio.h>
	
int main (void)
{
	puts("hello,world!\n");
	return 0;
}
```   

> helloworld程序的执行过程   
> - 用户告诉**操作系统**执行本程序     
> - **操作系统**找到程序的相关信息，检查是否是可执行文件，并根据程序首部信息确定代码和数据在可执行文件的位置并计算出对应的
磁盘块地址   (文件格式，windows是PE，linux是ELF)     
> - **操作系统**创建新的进程，将helloworld可执行文件映射到该进程结构，表示由该进程执行helloworld程序     
> - **操作系统**为helloworld程序设置CPU上下文环境，并跳到程序开始处(假设调度程序选中helloworld程序)      
> - 执行helloworld程序第一条指令时，发生缺页异常      
> - **操作系统**分配一页物理内存，并将代码从磁盘读入内存，继续执行helloworld程序      
> - helloworld程序执行puts函数(系统调用)，在显示器上显示一字符串    
> - **操作系统**找到要将字符串送往的显示设备，通常该设备是由一进程控制的，所以**操作系统**要将字符串送往该进程   
> - **操作系统**控制设备的进程告诉设备的窗口系统，它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转化成像素，将
像素写入设备的存储映像区       
> - 视频硬件将像素转换成显示器可以接受的一组控制/数据信号    
> - 显示器解释该信号，激发液晶屏     
> - Ok,我们在屏幕上看到了hello，world！

> 从上面可以看出，在程序执行过程中，程序会不时的请求操作系统的服务，这看起来时而运行用户程序，时而运行操作系统程序。    
> 换个角度来看，就像操作系统调度helloworld程序执行，执行过程中又不断陷入操作系统，然后再调度。。。。    

## 操作系统的定义和作用    
### 什么是操作系统     
> 操作系统是计算机系统中的一个系统软件，是一些程序模块的集合     
> - 它能以尽量**有效合理**的方式组织和管理计算机软硬件资源     
> - 合理组织计算机的工作流程，控制程序的执行并向用户提供各种服务功能     
> - 使得用户方便灵活的使用计算机，使整个计算机系统高效率运行       

### 解读几个关键词   
* **有效**：系统效率，资源利用率    
> CPU利用率是否充足？IO设备是否忙碌？    

* 合理   
> 各种软硬件资源的管理是否公平合理？   如果不公平不合理，会产生什么样的问题？    

* 方便实用    
> 两种角度：用户界面与编程接口     

### 操作系统的三个作用   
> - 资源的管理者 -> 有效   
> > - 硬件资源：  CPU，内存，设备(I/O设备，时钟，磁盘，网络卡)   
> > - 软件资源：  磁盘上的文件，各类管理信息     
> - 向用户提出各种服务 -> 方便使用   
> - 对硬件机器的扩展  -> 扩展能力   

#### 怎么管理资源  
* 跟踪记录资源的使用情况      (数据结构)
> 如哪些资源被使用？被哪个进程使用？使用多长时间？  

* 确定资源分配策略  (算法)   
> - 静态分配策略 ：进程执行之前，先把资源分配好，直到进程结束，资源才被回收    
> - 动态分配策略 ：进程在执行过程中，什么时候需要资源，什么时候提出申请  资源利用率高    

* 实施资源的分配与回收     
* 提高资源利用率    
* 保护资源的使用   
* 协调多个进程对资源请求的冲突   

#### 从资源管理的角度，操作系统有5大基本功能   
* 进程/线程管理 (CPU管理)   
> 进程线程状态，控制，同步互斥，通信，调度等   

* 存储管理    
> 内存分配/回收，地址转换，存储保护，内存扩充  
 
* 文件管理  
> 文件目录，文件操作，磁盘空间，文件存取控制    

* 设备管理   
> 设备驱动，分配回收，缓冲技术    

* 用户接口   
> 系统命令，编程接口   

#### 操作系统是各种服务的提供者   
操作系统为用户提供了一组功能强大，方便易用的命令和系统调用    
* 典型的服务   
> 进程的创建和执行，文件和目录的操作，I/O设备的使用，各类统计信息      

#### 操作系统是硬件之上的第一层软件    
> 操作系统之上是应用程序，之下是计算机硬件，与应用程序之间构成**虚拟机器界面**，与硬件之间构成**物理机器界面**    

##### 为什么要用操作系统将底层的硬件屏蔽呢    
因为与硬件有关的工作复杂繁琐   
> 比如“从磁盘文件中读取某个数据块”   和   “移动磁头，等待放下”   

#### 操作系统是对硬件机器的扩展   
* 操作系统在应用程序和硬件之间建立一个等价的扩展机器(虚拟机)     
* 对硬件进行抽象，提高了可移植性，比底层硬件更容易     

## 操作系统的主要特征    
* 并发     
> 能够同时处理多个同时性的活动的能力    
> ### 由并发引发的问题    
> 活动的切换，活动的保护，相互依赖活动的同步     
> ### 在计算机中同时存在多个程序运行(单CPU)    
> - 宏观上： 这些程序同时运行    
> - 微观上： 任何时刻只有一个程序真正的执行，即这些程序在CPU上是轮流执行的     
> ## 并发与并行    
> 并行与并发类似，但多指不同程序同时在多个硬件部件上执行     
    
* 共享       
> 操作系统和用户程序共同使用计算机的资源。   
> 操作系统要对系统资源合理的分配和使用，资源在一个时间段交替的被多个进程使用     
> * 互斥共享  (打印机)  
> * 同时共享 (可重入代码，磁盘文件)    

* 虚拟       
> 一个物理实体映射为若干个对应的逻辑实体(分时或分空间)   
> 虚拟是操作系统管理资源的重要手段，可提高资源利用率 
   
### 例子  
> - CPU : 每个进程的“虚处理器”   
> - 存储器 ： 每个进程都有自己独立的虚拟地址空间 (代码+数据+堆栈)   
> - 显示设备 ： 多窗口和虚拟终端      
  
* 随机     
> 操作系统必须随时对**以不可预测的次序**发生的时间进行响应和处理    

### 例子   
> 进程的运行速度不可预知，多个进程并发执行，走走停停，无法预测每个进程运行推进的快慢    
> 难以重现系统在某个时刻的状态      

## 典型操作系统的架构    
### Windows操作系统架构   
> 分为用户态和内核态     

#### 内核态    
> - 最下端是硬件抽象层(HAL)，屏蔽了具体的计算机硬件   
> - 内核(Kernel),主要是线程的管理，中断，陷入和异常的处理，同步    
> - 设备驱动程序，各种设备驱动程序，文件系统驱动程序，过滤器驱动程序    
> - win32用户GDI，图形和窗口     
> - 执行体，包括进程线程管理，虚存管理，I/O管理，对象管理器，向外提供各种可调用接口，通过**内核态可调用接口**和
**系统服务分发器**向上与动态链接库相接。   
> - Ntdll.dll,提供一组函数供用户态程序使用      

> 与硬件有关的是**硬件抽象层**和**内核**，不同的体系结构是在**内核**中区别的，相同体系结构的不同计算机是
在**硬件抽象层**区别的      
   
#### 用户态    
> - 包括系统进程，服务进程，用户进程，win32环境子系统(封装了大量的函数，供用户使用)    
> - 动态链接库    
   
### Unix操作系统架构    
> 从内向外依次是**硬件**，**内核**，**系统调用接口**和**Unix命令和库**         

#### 内核态    
> - 硬件控制层       
> - 进程控制子系统，包括调度，进程间通信和存储管理    
> - 文件子系统     
> - 设备驱动程序，分为块设备和字符设备    
> - 系统调用接口，提供给用户程序使用     

### Linux操作系统架构    
#### 内核态   
> - 进程和调度   
> - 虚存管理  
> - 物理内存管理   
> - 文件系统   
> - 字符设备驱动程序   
> - 块设备驱动程序    
> - 网络设备驱动程序   
> - 网络协议栈   
> - 中断处理   
> - 陷入和异常处理   
> - 系统调用接口       
   
## 操作系统的分类       
### 操作系统的发展历程     
> 大型机-个人计算机-网络-移动计算-云计算-泛在计算-机器人   
   
* 发展的驱动因素   
> - 计算机硬件技术  
> - 应用的需求  
> - 软件新技术的出现   

* 发展的目标  
> - 充分的利用硬件    
> - 提供更好的服务   

### 传统操作系统分类    
> 目标和工作方式的不同   
    
1. 批处理操作系统    
> 单道批处理和多道批处理：每次选择的作业个数   
  
> * 工作方式      
> > 用户将作业交给系统操作员，系统操作员将许多用户的作业组成一批作业，输入计算机系统中形成**作业流**，启动操作系统，
系统自动，依次的执行每个作业，最后操作员将作业结果交给用户    

> * 目标     
> > 提高资源利用率，提高作业吞吐量     

> * 作业    
> > 包括用户程序，数据，作业说明书(作业控制语言，类似现在的脚本)    

> * 成批    
> > 用户提交作业以后，只能等待处理结果，不能干预作业的执行    

> * 批作业处理   
> > 对一批作业的每个作业进行相同的处理    

> * 问题   
> > 作业输入输出直接由主机完成，造成CPU处于等待状态    

> * 解决方案   
> > 利用卫星机：完成面向用户的输入输出，中间结果暂存在磁带和磁盘上     
    
> #### SPOOLING技术(同时的外围设备联机操作)     
> > 批处理系统通常采用的技术，又称假脱机技术       
> > 现代计算机的打印过程通常采用spooling技术  

> * 思想    
> > 利用磁盘作为缓冲，将输入，计算，输出分别组成独立的任务流，使IO和计算真正并行       

> * 基本原理   
> > 用户作业加载到磁盘上的**输入井**，按某种调度策略选择几个搭配得当的作业调入内存，作业运行结果送到磁盘上的**输出井**，
运行结果由**输出井**送到打印机    
     
2. 分时系统       
> 一台主机和多个终端，输入命令等待回答     

> * 时间片   
> > 操作系统以时间片为单位，轮流为每个终端用户服务，利用人的错觉，使用户感觉不到计算机为其他用户服务     

> * 目标  
> > 及时响应   

> #### 通用操作系统   
> > 分时系统和批处理系统结合，分时优先,批处理在后      
> > 前台：需要频繁交互的作业    
> > 后台：时间性要求不强的作业    
 
3. 实时操作系统      
> 能及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理，并控制实时设备和实时任务协调一直工作    

> * 分类  
> > - 实时过程控制：工业控制，航空，军事。。。 
> > - 实时通信处理：电讯，银行，飞机订票     

> * 目标  
> > - 对外部目标在严格时间范围内作出响应   
> > - 高可靠性   
   
> * 特征 
> > 关键参数是**时间**  
> > 根据时间又分为**硬实时操作系统**(绝对在严格规定时间内)和**软实时操作系统**(偶尔有违反最终时限)   
  
4. 个人计算机操作系统      
> 计算机在某段时间只为一个用户服务    

> * 追求的目标  
> > - 界面友好，使用方便   
> > - 有丰富的应用软件   
 
5. 网络操作系统      
> 基于计算机网络，在各种操作系统中加入网络协议栈   

> * 功能  
> > 网络管理，安全，通信，资源共享和各种网路应用   

> * 目标   
> > 相互通信，资源共享   

6. 分布式操作系统 
> 是一个统一的操作系统，允许若干台计算机相互协作共同完成一项任务，自动实现全系统内的任务分配，自动调度，均衡负载      
 
> #### 分布式系统      
> > 以计算机网络或多处理机为基础，基本特征是处理分布在不同计算机上      

> * 特点   
> > 处理能力增强，速度更快，可靠性增强，具有透明性    
 
7. 嵌入式操作系统    

### 操作系统的另一种分类    
* 大型机操作系统   
* 服务器操作系统   
* 多处理机操作系统   
* 个人计算机操作系统   
* 掌上计算机操作系统   
* 嵌入式操作系统    
* 传感器节点操作系统   
* 实时操作系统  
* 智能卡操作系统   

 






